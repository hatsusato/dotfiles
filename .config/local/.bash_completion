#!/bin/bash

# USAGE: _complete-emulate CMD
# emulate completion invocation of CMD
_complete-emulate() {
  local cmd=$1 arg next
  local -a params opts reply
  local -i i
  params=($(complete -p "$cmd" 2>/dev/null))
  [[ ${params[0]} == complete && ${params[-1]} == $cmd ]] || return
  for ((i=1; i<${#params[@]}-1; i++)); do
    arg=${params[i]} next=${params[i+1]}
    case $arg in
      -[abcdefgjksuv])
        opts+=($arg);;
      -o)
        compopt -o "$next" >/dev/null
        let i++;;
      -[AGWCXPS])
        opts+=($arg "$next")
        let i++;;
      -F)
        reply=("$next")
        let i++;;
      *)
        echo ERROR: invalid complete: $(complete -p "$cmd") >&2
        return 1;;
    esac
  done
  local cur prev words cword
  _init_completion || return
  if ((${#reply[@]})); then
    "${reply[@]}" "$cmd" "$cur" "$prev"
  else
    readarray -t reply < <(compgen "${opts[@]}" -- "$cur")
    ((${#reply[@]})) && COMPREPLY=($(printf '%q\n' "${reply[@]}"))
  fi
}

# USAGE: _complete-split VARNAME STRING
# split STRING by COMP_WORDBREAKS and store them to VARNAME array
_complete-split() {
  local w=
  local -a list
  local -i i
  (($# == 2)) || return
  for ((i=0; i<${#2}; i++)); do
    local c=${2:i:1}
    if [[ $c == [$COMP_WORDBREAKS] ]]; then
      [[ $w ]] && list+=("$w")
      list+=("$c")
      w=
    else
      w+=$c
    fi
  done
  [[ $w ]] && list+=("$w")
  local "$1" && _upvars -a${#list[@]} "$1" "${list[@]}"
}
_complete-parse() {
  local e w= q=
  list=()
  for e; do
    if [[ -n $q ]]; then
      w+=$e
      [[ $q == $e ]] && q=
      continue
    fi
    case $e in
      [$IFS]) [[ -n "$w" ]] && list+=("$w")
              w=;;
      [\'\"]) q=$e
              w+=$e;;
      [\|\&]) list=()
              w=;;
      *) w+=$e;;
    esac
  done
  [[ -n "$w" ]] && list+=("$w")
}
_complete-replace() {
  local list=()
  _complete-split list "$1"
  _complete-parse "${list[@]}"
  local line=${list[@]}
  COMP_LINE=${COMP_LINE/#$COMP_WORDS/$line}
  ((COMP_POINT += ${#line} - ${#COMP_WORDS}))
  ((COMP_CWORD += ${#list[@]} - 1))
  COMP_WORDS=("${list[@]}" "${COMP_WORDS[@]:1}")
}

_complete-alias-exists() {
  [[ -n $@ && -n ${BASH_ALIASES[$@]+x} ]]
}

_complete-alias() {
  _complete-alias-exists "$COMP_WORDS" || return
  _complete-replace "${BASH_ALIASES[$COMP_WORDS]}"
  local comp=$(complete -p "$COMP_WORDS" 2>/dev/null)
  if [[ -z $comp ]]; then
    _completion_loader "$COMP_WORDS"
  elif [[ $comp == @(complete -F _complete-alias )* ]]; then
    complete -F _minimal -- "$COMP_WORDS" && return 124
  else
    _complete-emulate ${BASH_ALIASES[$COMP_WORDS]}
  fi
}

_complete-reuse() {
  (($# == 2)) || return
  __load_completion "$1" || return
  local args=($(complete -p "$1"))
  args[-1]="$2"
  "${args[@]}"
}

_auto-completion-loader() {
  __load_completion "$1" && return 124
  if _complete-alias-exists "$1"; then
    complete -F _complete-alias -- "$1" && return 124
  fi
  complete -F _minimal -- "$1" && return 124
} && complete -D -F _auto-completion-loader

complete-debug() {
  local comp log=${DEBUG+/tmp/$USER/debug.log}
  { for comp in words point line cword wordbreaks; do
      declare -p COMP_${comp^^}
    done
    echo
  } >>${log:-/dev/null}
}

_alias-complete-parse() {
  local -a words
  _alias-complete-parse-split() {
    local c q
    local -i i
    for ((i=0; i<${#1}; i++)); do
      c=${1:i:1}
      if [[ $c == [\\] ]]; then
        c=${1:i:2}
        let i++ && :
      fi
      if [[ $q ]]; then
        [[ $c == $q ]] && q=
      else
        [[ $c == [\"\'] ]] && q=$c
        words+=('')
      fi
      words[-1]+=$c
    done
  }
  _alias-complete-parse-join() {
    local w prev= next
    words=()
    for w; do
      case $w in
        ["$IFS"]) prev=; continue;;
        [\"\']) next=normal;;
        [';|&(']) prev=; words=(); continue;;
        ["$COMP_WORDBREAKS"]) next=break;;
        *) next=normal;;
      esac
      [[ $prev == $next ]] || words+=('')
      words[-1]+=$w
      prev=$next
    done
  }
  _alias-complete-parse-split "$2"
  _alias-complete-parse-join "${words[@]}"
  local "$1" && _upvars -a${#words[@]} "$1" "${words[@]}"
}
_alias-complete-reset-comp() {
  local cmd=$1 alias=${BASH_ALIASES[$1]} line
  local -a words args
  local -i point cword
  _alias-complete-parse words "$alias"
  let point=$COMP_POINT+${#alias}-${#cmd} && :
  let cword=$COMP_CWORD+${#words[@]}-1 && :
  line=$alias${COMP_LINE#$cmd}
  words+=("${COMP_WORDS[@]:1}")
  args+=(-v COMP_POINT $point)
  args+=(-v COMP_CWORD $cword)
  args+=(-v COMP_LINE "$line")
  args+=(-a${#words[@]} COMP_WORDS "${words[@]}")
  local COMP_{POINT,CWORD,LINE,WORDS} && _upvars "${args[@]}"
}
_alias-complete-emulate() {
  local cmd=$1 comp
  local -a opts reply
  comp=$(complete -p "$cmd" 2>/dev/null) || return
  set -- $comp
  [[ ${1-} == complete && ${@: -1} == $cmd ]] || return
  shift
  while (($# > 1)); do
    case $1 in
      -[abcdefgjksuv]) opts+=($1); shift 1;;
      -o) compopt -o "$2"; shift 2;;
      -[AGWCXPS]) opts+=($1 "$2"); shift 2;;
      -F) reply=("$2"); shift 2;;
      *) echo "ERROR: invalid complete: $comp" >&2; return 1;;
    esac
  done
  local cur prev words cword
  _init_completion || return
  if [[ "${reply[*]}" ]]; then
    "${reply[@]}" "$cmd" "$cur" "$prev"
  else
    readarray -t reply < <(compgen "${opts[@]}" -- "$cur")
    ((${#reply[@]})) && COMPREPLY=($(printf '%q\n' "${reply[@]}"))
  fi
}
_alias-complete() {
  local cmd=$1 comp
  if [[ -v BASH_ALIASES[$cmd] ]]; then
    _alias-complete-reset-comp "$cmd"
    cmd=${COMP_WORDS[0]}
  fi
  comp=$(complete -p "$cmd" 2>/dev/null) || _alias-completion-loader "$cmd"
  [[ $comp == *' -F _alias-complete '* ]] && complete -F _minimal -- "$cmd"
  _alias-complete-emulate "$cmd"
}
_alias-completion-loader() {
  local cmd=${1:-_EmptycmD_}
  __load_completion "$cmd" && return 124
  complete -F _alias-complete -- "$cmd" && return 124
} && complete -D -F _alias-completion-loader
