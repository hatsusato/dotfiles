#!/bin/bash

_complete-reuse() {
  (($# == 2)) || return
  complete -p "$1" &>/dev/null || __load_completion "$1"
  $(complete -p "$1" 2>/dev/null || echo false) "$2"
}

_alias-complete-parse() {
  local -a words
  _alias-complete-parse-split() {
    local c q
    local -i i
    for ((i=0; i<${#1}; i++)); do
      c=${1:i:1}
      if [[ $c == [\\] ]]; then
        c=${1:i:2}
        let i++ && :
      fi
      if [[ $q ]]; then
        [[ $c == $q ]] && q=
      else
        [[ $c == [\"\'] ]] && q=$c
        words+=('')
      fi
      words[-1]+=$c
    done
  }
  _alias-complete-parse-join() {
    local w prev= next
    words=()
    for w; do
      case $w in
        ["$IFS"]) prev=; continue;;
        [\"\']) next=normal;;
        [';|&(']) prev=; words=(); continue;;
        ["$COMP_WORDBREAKS"]) next=break;;
        *) next=normal;;
      esac
      [[ $prev == $next ]] || words+=('')
      words[-1]+=$w
      prev=$next
    done
  }
  _alias-complete-parse-split "$2"
  _alias-complete-parse-join "${words[@]}"
  local "$1" && _upvars -a${#words[@]} "$1" "${words[@]}"
}
_alias-complete-reset-comp() {
  local cmd=${COMP_WORDS[0]} alias line
  local -a words args
  local -i point cword
  alias=${BASH_ALIASES[$cmd]}
  _alias-complete-parse words "$alias"
  let point=$COMP_POINT+${#alias}-${#cmd} && :
  let cword=$COMP_CWORD+${#words[@]}-1 && :
  line=$alias${COMP_LINE#$cmd}
  words+=("${COMP_WORDS[@]:1}")
  args+=(-v COMP_POINT $point)
  args+=(-v COMP_CWORD $cword)
  args+=(-v COMP_LINE "$line")
  args+=(-a${#words[@]} COMP_WORDS "${words[@]}")
  local COMP_{POINT,CWORD,LINE,WORDS} && _upvars "${args[@]}"
}
_alias-complete-emulate() {
  local cmd=$1 comp
  local -a opts reply
  comp=$(complete -p "$cmd" 2>/dev/null) || return
  set -- $comp
  [[ ${1-} == complete && ${@: -1} == $cmd ]] || return
  shift
  while (($# > 1)); do
    case $1 in
      -[abcdefgjksuv]) opts+=($1); shift 1;;
      -o) compopt -o "$2"; shift 2;;
      -[AGWCXPS]) opts+=($1 "$2"); shift 2;;
      -F) reply=("$2"); shift 2;;
      *) echo "ERROR: invalid complete: $comp" >&2; return 1;;
    esac
  done
  local cur prev words cword
  _init_completion || return
  if [[ "${reply[*]}" ]]; then
    "${reply[@]}" "$cmd" "$cur" "$prev"
  else
    readarray -t reply < <(compgen "${opts[@]}" -- "$cur")
    ((${#reply[@]})) && COMPREPLY=($(printf '%q\n' "${reply[@]}"))
  fi
}
_alias-complete() {
  local cmd=${COMP_WORDS[0]} comp
  if [[ -v BASH_ALIASES[$cmd] ]]; then
    _alias-complete-reset-comp
    cmd=${COMP_WORDS[0]}
  fi
  comp=$(complete -p "$cmd" 2>/dev/null) || _alias-completion-loader "$cmd"
  [[ $comp == *' -F _alias-complete '* ]] && complete -F _minimal -- "$cmd"
  _alias-complete-emulate "$cmd"
}
_alias-completion-loader() {
  local cmd=${1:-_EmptycmD_}
  __load_completion "$cmd" && return 124
  complete -F _alias-complete -- "$cmd" && return 124
} && complete -D -F _alias-completion-loader
